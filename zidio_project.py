# -*- coding: utf-8 -*-
"""Zidio Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1asN4U9pzjSCWVR73KQK0uqUZBVjHMipq

# **Importing All Needed Libraries**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.arima.model import ARIMA
from prophet import Prophet
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM

"""## **Importing Data**"""

df=pd.read_csv('Toyota_Data.csv')
df.head()

"""Converting the index from Date to DateTimestamp"""

#droping the null values
df.dropna(inplace=True)
#converting data into datetime index
df.reset_index(inplace=True)
df['Date']=pd.to_datetime(df['Date'])
df.set_index('Date', inplace=True)

df.head()

"""# **Plotting The Data**"""

import matplotlib.pyplot as plt

df['Close'].plot(title="Stock Closing Price Over Time",figsize=(10,5))
plt.xlabel("Date")
plt.ylabel("Close Price")
plt.show()

"""# **Stationary test**"""

from statsmodels.tsa.seasonal import seasonal_decompose

decomposition = seasonal_decompose(df['Close'], model='additive', period=12)  # Use 12 for monthly data
decomposition.plot()
plt.show()

from statsmodels.tsa.stattools import adfuller
import pandas as pd

result = adfuller(df['Close'])

print('ADF Statistic:', result[0])
print('p-value:', result[1])
print('Used lags:', result[2])
print('Number of observations:', result[3])
print('Critical Values:')
for key, value in result[4].items():
    print(f'   {key}: {value}')

"""P value of stationary test should be **less then 0.5** but we got our p value more than 0.5 so the data is not stationary so we have to convert the data into stationary
here we have to do differenciation to make stationary

# Differentiating the data to make stationary
"""

df['diff'] = df['Close'].diff().dropna()

"""Again the stationary test is done (ADF Test)"""

adfuller(df['diff'].dropna())

"""As we got p value 0.0 so the data is stationary and now we are able to do ARIMA test and Sarima test

# **ARIMA Test**
"""

model_arima = ARIMA(df['Close'], order=(5, 1, 0))
result_arima = model_arima.fit()
forecast_arima = result_arima.forecast(steps=30)

plt.figure(figsize=(12,6))
plt.plot(df['Close'], label='Actual')
plt.plot(forecast_arima.index, forecast_arima, label='ARIMA Forecast', color='red')
plt.title('ARIMA Forecast')
plt.legend()
plt.grid(True)
plt.show()

"""# **SARIMA Model**"""

from statsmodels.tsa.statespace.sarimax import SARIMAX

# SARIMA example order: (1,1,1)(1,1,1,12) for monthly seasonality
sarima_model = SARIMAX(df['Close'], order=(1,1,1), seasonal_order=(1,1,1,12))
sarima_result = sarima_model.fit()

# Forecast
forecast_sarima = sarima_result.forecast(60)

# Plot
plt.figure(figsize=(12,6))
plt.plot(df['Close'], label='Actual')
plt.plot(forecast_sarima.index, forecast_sarima, label='Forecast', color='orange')
plt.title('SARIMA Forecast')
plt.legend()
plt.show()

"""# **prophet Model**"""
!pip install prophet

from prophet import Prophet

# Prophet needs columns 'ds' and 'y'
prophet_df = df.reset_index()[['Date', 'Close']]
prophet_df.columns = ['ds', 'y']

# Create and fit model
m = Prophet()
m.fit(prophet_df)

# Make future dataframe
future = m.make_future_dataframe(periods=60)
forecast = m.predict(future)

# Plot forecast
fig1 = m.plot(forecast)
plt.title('Prophet Forecast')
plt.show()

import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

# Prepare data
close = df[['Close']]
scaler = MinMaxScaler()
close_scaled = scaler.fit_transform(close)

# Create sequences
def create_sequences(data, time_steps=60):
    X, y = [], []
    for i in range(time_steps, len(data)):
        X.append(data[i-time_steps:i])
        y.append(data[i])
    return np.array(X), np.array(y)

X, y = create_sequences(close_scaled)
X_train, y_train = X[:-60], y[:-60]  # Last 60 for testing
X_test, y_test = X[-60:], y[-60:]

#"""***LSTM***"""

# LSTM model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(X.shape[1], 1)))
model.add(LSTM(50))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mse')
model.fit(X_train, y_train, epochs=10, batch_size=32)

# Predict
predicted = model.predict(X_test)
predicted_prices = scaler.inverse_transform(predicted)

# Plot
plt.figure(figsize=(12,6))
plt.plot(df.index[-60:], close[-60:], label='Actual')
plt.plot(df.index[-60:], predicted_prices, label='Predicted', color='green')
plt.title('LSTM Forecast')
plt.legend()
plt.show()
